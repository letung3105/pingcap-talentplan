use criterion::{
    black_box, criterion_group, criterion_main, BatchSize, Bencher, Criterion, Throughput,
};
use kvs::{KvStore, KvsEngine, SledKvsEngine};
use rand::{distributions::Alphanumeric, prelude::*};
use tempfile::TempDir;

const KEY_SIZE: usize = 1000;
const VAL_SIZE: usize = 1000;

criterion_main!(sequential);
criterion_group! {
    name = sequential;
    config = Criterion::default().significance_level(0.05).sample_size(1000);
    targets = write, read,
}

/// Call set on the same key-value store instance for every benchmark iteration, the key and
/// value will be randomly generated bytes sequences with size of `KEY_SIZE` and `VAL_SIZE`
pub fn write(c: &mut Criterion) {
    let mut g = c.benchmark_group("write");
    g.throughput(Throughput::Bytes((KEY_SIZE + VAL_SIZE) as u64));
    let tmpdir = TempDir::new().unwrap();
    let engine = KvStore::open(tmpdir.path()).unwrap();
    g.bench_with_input("kvs", &(engine, KEY_SIZE, VAL_SIZE), write_bench);

    g.throughput(Throughput::Bytes((KEY_SIZE + VAL_SIZE) as u64));
    let tmpdir = TempDir::new().unwrap();
    let db = sled::Config::default().path(tmpdir.path()).open().unwrap();
    let engine = SledKvsEngine::new(db);
    g.bench_with_input("sled", &(engine, KEY_SIZE, VAL_SIZE), write_bench);
    g.finish();
}

pub fn write_bench<E>(b: &mut Bencher, (engine, key_size, val_size): &(E, usize, usize))
where
    E: KvsEngine,
{
    let mut rng = StdRng::from_seed([0u8; 32]);
    b.iter_batched(
        || rand_key_value(&mut rng, *key_size, *val_size),
        |(k, v)| {
            engine.set(black_box(k), black_box(v)).unwrap();
        },
        BatchSize::SmallInput,
    );
}

/// Call get on a pre-populted key-value store instance for every benchmark iteration, the key
/// and value will be randomly generated bytes sequences with size of `KEY_SIZE` and `VAL_SIZE`
pub fn read(c: &mut Criterion) {
    let mut rng = StdRng::from_seed([0u8; 32]);
    let kv_pairs = prebuilt_kv_pairs(&mut rng, 100, KEY_SIZE, VAL_SIZE);

    let mut g = c.benchmark_group("read");
    g.throughput(Throughput::Bytes(KEY_SIZE as u64));
    let tmpdir = TempDir::new().unwrap();
    let engine = KvStore::open(tmpdir.path()).unwrap();
    g.bench_with_input("kvs", &(engine, &kv_pairs), read_bench);

    g.throughput(Throughput::Bytes((KEY_SIZE + VAL_SIZE) as u64));
    let tmpdir = TempDir::new().unwrap();
    let db = sled::Config::default().path(tmpdir.path()).open().unwrap();
    let engine = SledKvsEngine::new(db);
    g.bench_with_input("sled", &(engine, &kv_pairs), read_bench);
    g.finish();
}

pub fn read_bench<E>(b: &mut Bencher, (engine, kv_pairs): &(E, &Vec<(String, String)>))
where
    E: KvsEngine,
{
    let mut rng = StdRng::from_seed([0u8; 32]);
    kv_pairs
        .iter()
        .for_each(|(k, v)| engine.set(k.clone(), v.clone()).unwrap());

    b.iter_batched(
        || kv_pairs.choose(&mut rng).cloned().unwrap(),
        |(k, v)| {
            assert_eq!(Some(v), engine.get(black_box(k)).unwrap());
        },
        BatchSize::SmallInput,
    );
}

fn prebuilt_kv_pairs<R>(
    rng: &mut R,
    size: usize,
    key_size: usize,
    val_size: usize,
) -> Vec<(String, String)>
where
    R: Rng,
{
    (0..size)
        .into_iter()
        .map(|_| rand_key_value(rng, key_size, val_size))
        .collect()
}

fn rand_key_value<R>(rng: &mut R, key_size: usize, val_size: usize) -> (String, String)
where
    R: Rng,
{
    let key: String = rng
        .sample_iter(Alphanumeric)
        .take(key_size)
        .map(char::from)
        .collect();
    let val: String = rng
        .sample_iter(Alphanumeric)
        .take(val_size)
        .map(char::from)
        .collect();
    (key, val)
}
